// Code generated by counterfeiter. DO NOT EDIT.
package queuefakes

import (
	"sync"

	"github.com/amclay/queue"
)

type FakeQueue struct {
	AppendStub        func(interface{})
	appendMutex       sync.RWMutex
	appendArgsForCall []struct {
		arg1 interface{}
	}
	BackStub        func() interface{}
	backMutex       sync.RWMutex
	backArgsForCall []struct {
	}
	backReturns struct {
		result1 interface{}
	}
	backReturnsOnCall map[int]struct {
		result1 interface{}
	}
	CleanStub        func()
	cleanMutex       sync.RWMutex
	cleanArgsForCall []struct {
	}
	FrontStub        func() interface{}
	frontMutex       sync.RWMutex
	frontArgsForCall []struct {
	}
	frontReturns struct {
		result1 interface{}
	}
	frontReturnsOnCall map[int]struct {
		result1 interface{}
	}
	LengthStub        func()
	lengthMutex       sync.RWMutex
	lengthArgsForCall []struct {
	}
	NewStub        func() *queue.QueueImpl
	newMutex       sync.RWMutex
	newArgsForCall []struct {
	}
	newReturns struct {
		result1 *queue.QueueImpl
	}
	newReturnsOnCall map[int]struct {
		result1 *queue.QueueImpl
	}
	PopStub        func() interface{}
	popMutex       sync.RWMutex
	popArgsForCall []struct {
	}
	popReturns struct {
		result1 interface{}
	}
	popReturnsOnCall map[int]struct {
		result1 interface{}
	}
	PrependStub        func(interface{})
	prependMutex       sync.RWMutex
	prependArgsForCall []struct {
		arg1 interface{}
	}
	RemoveStub        func(interface{}) bool
	removeMutex       sync.RWMutex
	removeArgsForCall []struct {
		arg1 interface{}
	}
	removeReturns struct {
		result1 bool
	}
	removeReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeQueue) Append(arg1 interface{}) {
	fake.appendMutex.Lock()
	fake.appendArgsForCall = append(fake.appendArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	fake.recordInvocation("Append", []interface{}{arg1})
	fake.appendMutex.Unlock()
	if fake.AppendStub != nil {
		fake.AppendStub(arg1)
	}
}

func (fake *FakeQueue) AppendCallCount() int {
	fake.appendMutex.RLock()
	defer fake.appendMutex.RUnlock()
	return len(fake.appendArgsForCall)
}

func (fake *FakeQueue) AppendCalls(stub func(interface{})) {
	fake.appendMutex.Lock()
	defer fake.appendMutex.Unlock()
	fake.AppendStub = stub
}

func (fake *FakeQueue) AppendArgsForCall(i int) interface{} {
	fake.appendMutex.RLock()
	defer fake.appendMutex.RUnlock()
	argsForCall := fake.appendArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueue) Back() interface{} {
	fake.backMutex.Lock()
	ret, specificReturn := fake.backReturnsOnCall[len(fake.backArgsForCall)]
	fake.backArgsForCall = append(fake.backArgsForCall, struct {
	}{})
	fake.recordInvocation("Back", []interface{}{})
	fake.backMutex.Unlock()
	if fake.BackStub != nil {
		return fake.BackStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.backReturns
	return fakeReturns.result1
}

func (fake *FakeQueue) BackCallCount() int {
	fake.backMutex.RLock()
	defer fake.backMutex.RUnlock()
	return len(fake.backArgsForCall)
}

func (fake *FakeQueue) BackCalls(stub func() interface{}) {
	fake.backMutex.Lock()
	defer fake.backMutex.Unlock()
	fake.BackStub = stub
}

func (fake *FakeQueue) BackReturns(result1 interface{}) {
	fake.backMutex.Lock()
	defer fake.backMutex.Unlock()
	fake.BackStub = nil
	fake.backReturns = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeQueue) BackReturnsOnCall(i int, result1 interface{}) {
	fake.backMutex.Lock()
	defer fake.backMutex.Unlock()
	fake.BackStub = nil
	if fake.backReturnsOnCall == nil {
		fake.backReturnsOnCall = make(map[int]struct {
			result1 interface{}
		})
	}
	fake.backReturnsOnCall[i] = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeQueue) Clean() {
	fake.cleanMutex.Lock()
	fake.cleanArgsForCall = append(fake.cleanArgsForCall, struct {
	}{})
	fake.recordInvocation("Clean", []interface{}{})
	fake.cleanMutex.Unlock()
	if fake.CleanStub != nil {
		fake.CleanStub()
	}
}

func (fake *FakeQueue) CleanCallCount() int {
	fake.cleanMutex.RLock()
	defer fake.cleanMutex.RUnlock()
	return len(fake.cleanArgsForCall)
}

func (fake *FakeQueue) CleanCalls(stub func()) {
	fake.cleanMutex.Lock()
	defer fake.cleanMutex.Unlock()
	fake.CleanStub = stub
}

func (fake *FakeQueue) Front() interface{} {
	fake.frontMutex.Lock()
	ret, specificReturn := fake.frontReturnsOnCall[len(fake.frontArgsForCall)]
	fake.frontArgsForCall = append(fake.frontArgsForCall, struct {
	}{})
	fake.recordInvocation("Front", []interface{}{})
	fake.frontMutex.Unlock()
	if fake.FrontStub != nil {
		return fake.FrontStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.frontReturns
	return fakeReturns.result1
}

func (fake *FakeQueue) FrontCallCount() int {
	fake.frontMutex.RLock()
	defer fake.frontMutex.RUnlock()
	return len(fake.frontArgsForCall)
}

func (fake *FakeQueue) FrontCalls(stub func() interface{}) {
	fake.frontMutex.Lock()
	defer fake.frontMutex.Unlock()
	fake.FrontStub = stub
}

func (fake *FakeQueue) FrontReturns(result1 interface{}) {
	fake.frontMutex.Lock()
	defer fake.frontMutex.Unlock()
	fake.FrontStub = nil
	fake.frontReturns = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeQueue) FrontReturnsOnCall(i int, result1 interface{}) {
	fake.frontMutex.Lock()
	defer fake.frontMutex.Unlock()
	fake.FrontStub = nil
	if fake.frontReturnsOnCall == nil {
		fake.frontReturnsOnCall = make(map[int]struct {
			result1 interface{}
		})
	}
	fake.frontReturnsOnCall[i] = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeQueue) Length() {
	fake.lengthMutex.Lock()
	fake.lengthArgsForCall = append(fake.lengthArgsForCall, struct {
	}{})
	fake.recordInvocation("Length", []interface{}{})
	fake.lengthMutex.Unlock()
	if fake.LengthStub != nil {
		fake.LengthStub()
	}
}

func (fake *FakeQueue) LengthCallCount() int {
	fake.lengthMutex.RLock()
	defer fake.lengthMutex.RUnlock()
	return len(fake.lengthArgsForCall)
}

func (fake *FakeQueue) LengthCalls(stub func()) {
	fake.lengthMutex.Lock()
	defer fake.lengthMutex.Unlock()
	fake.LengthStub = stub
}

func (fake *FakeQueue) New() *queue.QueueImpl {
	fake.newMutex.Lock()
	ret, specificReturn := fake.newReturnsOnCall[len(fake.newArgsForCall)]
	fake.newArgsForCall = append(fake.newArgsForCall, struct {
	}{})
	fake.recordInvocation("New", []interface{}{})
	fake.newMutex.Unlock()
	if fake.NewStub != nil {
		return fake.NewStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.newReturns
	return fakeReturns.result1
}

func (fake *FakeQueue) NewCallCount() int {
	fake.newMutex.RLock()
	defer fake.newMutex.RUnlock()
	return len(fake.newArgsForCall)
}

func (fake *FakeQueue) NewCalls(stub func() *queue.QueueImpl) {
	fake.newMutex.Lock()
	defer fake.newMutex.Unlock()
	fake.NewStub = stub
}

func (fake *FakeQueue) NewReturns(result1 *queue.QueueImpl) {
	fake.newMutex.Lock()
	defer fake.newMutex.Unlock()
	fake.NewStub = nil
	fake.newReturns = struct {
		result1 *queue.QueueImpl
	}{result1}
}

func (fake *FakeQueue) NewReturnsOnCall(i int, result1 *queue.QueueImpl) {
	fake.newMutex.Lock()
	defer fake.newMutex.Unlock()
	fake.NewStub = nil
	if fake.newReturnsOnCall == nil {
		fake.newReturnsOnCall = make(map[int]struct {
			result1 *queue.QueueImpl
		})
	}
	fake.newReturnsOnCall[i] = struct {
		result1 *queue.QueueImpl
	}{result1}
}

func (fake *FakeQueue) Pop() interface{} {
	fake.popMutex.Lock()
	ret, specificReturn := fake.popReturnsOnCall[len(fake.popArgsForCall)]
	fake.popArgsForCall = append(fake.popArgsForCall, struct {
	}{})
	fake.recordInvocation("Pop", []interface{}{})
	fake.popMutex.Unlock()
	if fake.PopStub != nil {
		return fake.PopStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.popReturns
	return fakeReturns.result1
}

func (fake *FakeQueue) PopCallCount() int {
	fake.popMutex.RLock()
	defer fake.popMutex.RUnlock()
	return len(fake.popArgsForCall)
}

func (fake *FakeQueue) PopCalls(stub func() interface{}) {
	fake.popMutex.Lock()
	defer fake.popMutex.Unlock()
	fake.PopStub = stub
}

func (fake *FakeQueue) PopReturns(result1 interface{}) {
	fake.popMutex.Lock()
	defer fake.popMutex.Unlock()
	fake.PopStub = nil
	fake.popReturns = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeQueue) PopReturnsOnCall(i int, result1 interface{}) {
	fake.popMutex.Lock()
	defer fake.popMutex.Unlock()
	fake.PopStub = nil
	if fake.popReturnsOnCall == nil {
		fake.popReturnsOnCall = make(map[int]struct {
			result1 interface{}
		})
	}
	fake.popReturnsOnCall[i] = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeQueue) Prepend(arg1 interface{}) {
	fake.prependMutex.Lock()
	fake.prependArgsForCall = append(fake.prependArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	fake.recordInvocation("Prepend", []interface{}{arg1})
	fake.prependMutex.Unlock()
	if fake.PrependStub != nil {
		fake.PrependStub(arg1)
	}
}

func (fake *FakeQueue) PrependCallCount() int {
	fake.prependMutex.RLock()
	defer fake.prependMutex.RUnlock()
	return len(fake.prependArgsForCall)
}

func (fake *FakeQueue) PrependCalls(stub func(interface{})) {
	fake.prependMutex.Lock()
	defer fake.prependMutex.Unlock()
	fake.PrependStub = stub
}

func (fake *FakeQueue) PrependArgsForCall(i int) interface{} {
	fake.prependMutex.RLock()
	defer fake.prependMutex.RUnlock()
	argsForCall := fake.prependArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueue) Remove(arg1 interface{}) bool {
	fake.removeMutex.Lock()
	ret, specificReturn := fake.removeReturnsOnCall[len(fake.removeArgsForCall)]
	fake.removeArgsForCall = append(fake.removeArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	fake.recordInvocation("Remove", []interface{}{arg1})
	fake.removeMutex.Unlock()
	if fake.RemoveStub != nil {
		return fake.RemoveStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeReturns
	return fakeReturns.result1
}

func (fake *FakeQueue) RemoveCallCount() int {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return len(fake.removeArgsForCall)
}

func (fake *FakeQueue) RemoveCalls(stub func(interface{}) bool) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = stub
}

func (fake *FakeQueue) RemoveArgsForCall(i int) interface{} {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	argsForCall := fake.removeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueue) RemoveReturns(result1 bool) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	fake.removeReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeQueue) RemoveReturnsOnCall(i int, result1 bool) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	if fake.removeReturnsOnCall == nil {
		fake.removeReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.removeReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeQueue) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.appendMutex.RLock()
	defer fake.appendMutex.RUnlock()
	fake.backMutex.RLock()
	defer fake.backMutex.RUnlock()
	fake.cleanMutex.RLock()
	defer fake.cleanMutex.RUnlock()
	fake.frontMutex.RLock()
	defer fake.frontMutex.RUnlock()
	fake.lengthMutex.RLock()
	defer fake.lengthMutex.RUnlock()
	fake.newMutex.RLock()
	defer fake.newMutex.RUnlock()
	fake.popMutex.RLock()
	defer fake.popMutex.RUnlock()
	fake.prependMutex.RLock()
	defer fake.prependMutex.RUnlock()
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeQueue) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ queue.Queue = new(FakeQueue)
